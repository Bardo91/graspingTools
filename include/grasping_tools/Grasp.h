///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef GPISGRASPING_GRASP_H_
#define GPISGRASPING_GRASP_H_

#include <armadillo>
#include <vector>

#include <grasping_tools/ContactPoint.h>
#include <grasping_tools/Object.h>

// Forward declaration
namespace orgQhull{
	class Qhull;
}

namespace grasping_tools {
	class Grasp {
	public:
		Grasp();
		Grasp(const arma::colvec3& _objectCenter, const std::vector<ContactPoint> & _contactPoints);

		void contactPoints(std::vector<ContactPoint> &_contactPoints);

		void objectCentroid(const arma::colvec3& _objectCentroid);

		/// Get list of contact points
		/// \return std vector with ContactPoints
		std::vector<ContactPoint> contactPoints() const;

		/// Compute grasp matrix using current contact points.
		/// \return true if worked, false if failed
		bool computeGraspMatrix();

		/// Get grasp matrix
		/// \return grasp matrix with geometrical properties of the grasp
		arma::mat graspMatrix() const;

		/// Get rank of grasp matrix
		/// \return the rank of the grasp matrix. Ideally, full rank matrix
		unsigned rank();

		/// Compute quality metrics that take into account the algebraic properties of the Grasp Matrix G.
		/// \return true if quality metrics are computed
		bool computeQualityMetricsofG();

		/// Get the minimum singular value of the grasp matrix
		/// \return minimum singular value
		double minSingularValue();

		/// Get the area/volume of the ellisoid generated by G
		/// \return area
		double areaEllipsoid();

		/// Get the grasp isotropy index of of G
		/// \return isotropy index
		double graspIsotropyIndex();

		/// Compute the 6-dimensional cone resulting of the union of the friction cones of the contact points.
		/// \param _pointsPerContact: number of points used to approximate the each of the contact friction crones
		/// \return matrix containing by columns the vectors that define the approximation of wrench's cone.
		arma::mat aprxWrenchCone(unsigned _pointsPerContact);

		/// Determine if the current grasp has force closure.
		/// \return true if grasp has force closure
		bool hasForceClosure();

		/// Compute approximate largest-minimum resisted wrench (lmrw). DEPRECATED
		/// \return approximate value of lmrw
		double apprLmrw();

		/// Compute exact largest-minimum resisted wrench (lmrw) from convex hull. This method uses Qhull.
		/// \return largest-minimum resisted wrench
		double lmrw();

		/// Compute task specific wrenches from convex hull.
		/// \return vector containing the maximum value resisted at each axis of the wrench space (Fx, Fy, Fz, Tx, Ty, Tz)
		std::vector<double> taskWrenches();

		/// Compute probability of force closure. This method is computed only if the contact points are generated with 
		/// probabilistic information (i.e. from a probabilistic representation of an object)
		/// \return probability of force closure.
		double probabilityForceClosure(unsigned _samples = 100);

		/// Overrided operator=.
		void operator=(const Grasp &_grasp);

	private:
		void checkForceClosure();
		bool prepareQhull();

	private:
		arma::colvec3				mObjectCenter;
		std::vector<ContactPoint>	mContactPoints;
		arma::mat mGraspMatrix;

		unsigned mRank;

		double mMinSingularValueG;
		double mMaxSingularValueG;
		double mAreaG;
		double mGraspIsotropyIndexG;

		const double cEpsilonDistance = 1e-5;
		arma::mat mConvexConeGrasp;
		bool mHasForceClosure;
		double mLmrw;
		std::vector<double> mTaskWrench;

		orgQhull::Qhull *mQHull = nullptr;

		bool mComputedGraspMatrix		= false;
		bool mComputedQualityMetrics	= false;
		bool mComputedForceClosure		= false;
		bool mComputedConvexCone		= false;
		bool mComputedApprxLmrw			= false;
		bool mComputedLmrw				= false;
		bool mComputedTaskWrench		= false;
	};
}	//	gpisGrasping

#endif	//	GPISGRASPING_GRASP_H_
